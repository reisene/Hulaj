{"version":3,"file":"counters.js","sources":["counters.js"],"sourcesContent":["/**\r\n * Initializes and animates counters when they become visible in the viewport.\r\n * The counters are identified by the 'counter' class and are animated using the 'initCounters' function.\r\n * The function also handles scroll events to trigger the counter animations.\r\n */\r\n$(document).ready(function () {\r\n \r\n    // Initializes counter elements with animation upon scrolling or loading.\r\n    $('.timer').counterUp({\r\n        delay: 10,\r\n        time: 1000,\r\n    });\r\n\r\n    /**\r\n     * @description Initializes and starts a timer on every element with class `timer`.\r\n     * It sets up an incrementing counter to reach the value specified in `data-to`\r\n     * attribute, at a speed defined by `data-speed`, updating the element's text display\r\n     * every 100 milliseconds.\r\n     */\r\n    const initCounters = () => {\r\n        $('.timer').each(function () {\r\n            // Initializes a timer.\r\n            \r\n            var countTo = parseInt($(this).attr('data-to'));\r\n            var speed = parseInt($(this).attr('data-speed'));\r\n            var count = 0;\r\n            var increment = countTo / (speed / 100); // increment per step\r\n\r\n            var $this = $(this);\r\n            var counter = setInterval(function () {\r\n                // Increments and updates text every second, stopping at a certain value.\r\n                count += increment;\r\n                if (count >= countTo) {\r\n                    count = countTo;\r\n                    clearInterval(counter);\r\n                }\r\n                $this.text(Math.floor(count));\r\n            }, 100);\r\n        });\r\n    };\r\n\r\n    const countersInitialized = new Set();\r\n\r\n    /**\r\n     * @description Iterates over elements with class \"counter\". It checks if each element\r\n     * is visible within the viewport and has not been initialized before, then calls\r\n     * `initCounters` to initialize it and adds it to a set for tracking initialization\r\n     * status.\r\n     */\r\n    const handleCounters = () => {\r\n        $('.counter').each(function () {\r\n            // Checks for elements in view and initializes them if not already initialized.\r\n            \r\n            if (isElementInView(this) && !countersInitialized.has(this)) {\r\n                \r\n                initCounters();\r\n                countersInitialized.add(this);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @description Triggers an execution of the `handleCounters` function every time a\r\n     * scroll event occurs, enabling dynamic updates to counters or other variables based\r\n     * on scrolling activity.\r\n     */\r\n    const handleScroll = () => {\r\n        handleCounters();\r\n    };\r\n\r\n    $(window).scroll(handleScroll);\r\n    handleScroll(); // Initialize scroll animations and counters on load\r\n});\r\n\r\n/**\r\n * @description Checks if a given HTML element is currently visible within its parent's\r\n * viewport by comparing its bounding rectangle coordinates to the inner dimensions\r\n * of the window or document element. It returns true if the element is visible, false\r\n * otherwise.\r\n *\r\n * @param {HTMLElement} element - Checked for visibility within the viewport.\r\n *\r\n * @returns {boolean} True if the element is currently visible within the viewport\r\n * and false otherwise.\r\n */\r\nfunction isElementInView(element) {\r\n    const rect = element.getBoundingClientRect();\r\n    return (\r\n        rect.top >= 0 &&\r\n        rect.left >= 0 &&\r\n        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\r\n        rect.right <= (window.innerWidth || document.documentElement.clientWidth)\r\n    );\r\n}"],"names":["isElementInView","element","rect","getBoundingClientRect","top","left","bottom","window","innerHeight","document","documentElement","clientHeight","right","innerWidth","clientWidth","$","ready","counterUp","delay","time","initCounters","each","countTo","parseInt","this","attr","speed","count","increment","$this","counter","setInterval","clearInterval","text","Math","floor","countersInitialized","Set","handleScroll","has","add","scroll"],"mappings":"AAqFA,SAASA,gBAAgBC,GACfC,EAAOD,EAAQE,sBAAsB,EAC3C,OACgB,GAAZD,EAAKE,KACQ,GAAbF,EAAKG,MACLH,EAAKI,SAAWC,OAAOC,aAAeC,SAASC,gBAAgBC,eAC/DT,EAAKU,QAAUL,OAAOM,YAAcJ,SAASC,gBAAgBI,YAErE,CAxFAC,EAAEN,QAAQ,EAAEO,MAAM,WAGdD,EAAE,QAAQ,EAAEE,UAAU,CAClBC,MAAO,GACPC,KAAM,GACV,CAAC,EAQD,IAAMC,EAAe,KACjBL,EAAE,QAAQ,EAAEM,KAAK,WAGb,IAAIC,EAAUC,SAASR,EAAES,IAAI,EAAEC,KAAK,SAAS,CAAC,EAC1CC,EAAQH,SAASR,EAAES,IAAI,EAAEC,KAAK,YAAY,CAAC,EAC3CE,EAAQ,EACRC,EAAYN,GAAWI,EAAQ,KAE/BG,EAAQd,EAAES,IAAI,EACdM,EAAUC,YAAY,WAGTT,IADbK,GAASC,KAELD,EAAQL,EACRU,cAAcF,CAAO,GAEzBD,EAAMI,KAAKC,KAAKC,MAAMR,CAAK,CAAC,CAChC,EAAG,GAAG,CACV,CAAC,CACL,EAEMS,EAAsB,IAAIC,IAyBhC,IAAMC,EAAe,KAhBjBvB,EAAE,UAAU,EAAEM,KAAK,WAGXrB,gBAAgBwB,IAAI,GAAK,CAACY,EAAoBG,IAAIf,IAAI,IAEtDJ,EAAa,EACbgB,EAAoBI,IAAIhB,IAAI,EAEpC,CAAC,CAUL,EAEAT,EAAER,MAAM,EAAEkC,OAAOH,CAAY,EAC7BA,EAAa,CACjB,CAAC"}